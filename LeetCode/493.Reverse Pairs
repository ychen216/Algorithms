493. Reverse Pairs
/*
Given an array nums, we call (i, j) an important reverse pair if i < j and nums[i] > 2*nums[j].

You need to return the number of important reverse pairs in the given array.

Example1:

Input: [1,3,2,3,1]
Output: 2
Example2:

Input: [2,4,3,5,1]
Output: 3
Note:
  The length of the given array will not exceed 50,000.
  All the numbers in the input array are in the range of 32-bit integer.
*/
Solution:
class Solution {
public:
    // 利用mergeSort求逆序数的方法
    int cnt;
    int reversePairs(vector<int>& nums) {
        cnt=0;
        mergeSort(nums,0,nums.size()-1);
        return cnt;
    }
private:
    void merge(vector<int>&nums,int i,int mid,int j){
        int p=i,q=mid+1;
        while(p<=mid){
            while(q<=j&&nums[p]/2.0>nums[q])q++;//写成除法的形式避免溢出
            cnt+=q-mid-1;
            p++;
        }
        sort(nums.begin()+i,nums.begin()+j+1);
    }
    void mergeSort(vector<int>&nums,int i,int j){
        if(i<j){
            int mid=i+(j-i)/2;
            mergeSort(nums,i,mid);
            mergeSort(nums,mid+1,j);
            merge(nums,i,mid,j);
        }
    }
};

update:
class Solution {
public:
    //利用归并排序的思想进行归并排序 然后再check左右两部分元素中满足条件的pair数目
    int reversePairs(vector<int>& nums) {
        int n=nums.size();
        return mergeSort(nums,0,n-1);
    }
private:   
    int mergeSort(vector<int>&nums,int s,int e){
        if(s>=e){
            return 0;
        }
        int mid=s+(e-s)/2;
        int res=mergeSort(nums,s,mid)+mergeSort(nums,mid+1,e);
        int i=s,j=mid+1;
        // check pair
        //为[s,mid]中的每一个元素i找到在[mid+1,e]中符合的j,满足nums[i]>nums[j]*2
        while(i<=mid){
            while(j<=e&&nums[i]/2.0>nums[j]){
                j++;
            }
            res+=j-mid-1;
            i++;
        }
        //merge操作 将[s,e]整合成有序数组
        sort(nums.begin()+s,nums.begin()+e+1);
        return res;
    }
};
