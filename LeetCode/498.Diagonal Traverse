498. Diagonal Traverse

/*
Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image.
*/

Solution:
class Solution {
public:
    /*
    If out of bottom border (row >= m) then row = m - 1; col += 2; change walk direction.
    if out of right border (col >= n) then col = n - 1; row += 2; change walk direction.
    if out of top border (row < 0) then row = 0; change walk direction.
    if out of left border (col < 0) then col = 0; change walk direction.
    Otherwise, just go along with the current direction.
    */
    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {
        int row=matrix.size();
        if(row==0)
            return {};
        int col=matrix[0].size();
        int cnt=row*col;
        vector<int>res;
        int dx[2]={-1,1};
        int dy[2]={1,-1};
        int i=0,j=0,d=0;//初始方向为向右上
        for(int k=0;k<cnt;k++){
            res.push_back(matrix[i][j]);
            i+=dx[d];
            j+=dy[d];
            
            
            if(i>=row){
                i=row-1;
                j+=2;
                d=1-d;
            }
            if(j>=col){
                i+=2;
                j=col-1;
                d=1-d;
            }
            if(i<0){
                i=0;
                d=1-d;//变方向
            }
            if(j<0){
                j=0;
                d=1-d;
            }           
        }
        return res;
    }
};


Solution 2:
class Solution {
public:
    /*
        模拟:每一次行进的路线都是对角线 x+y=k x,y分别是元素的横纵坐标
        当k%2==0时 朝上走
        当k%2==1时 朝下走
    */
    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {
        int M=matrix.size();
        if(M==0)
            return {};
        int N=matrix[0].size();
        int r=0,c=0,total=M*N;
        vector<int> res;
        for(int i=0;i<total;i++){
            res.push_back(matrix[r][c]);
            if((r+c)&1){
                //向下走
                // if else 的顺序很重要 向上走的情况也是同理
                // 必须先r==M-1 因为有时候同时满足 r==M-1&&c==0
                // 此时应该按照 r==M-1的情况行动
                if(r==M-1){
                    c++;
                }
                else if(c==0){
                    r++;
                }
                else{
                    r++;c--;    
                }
            }else{
                // 向上走
                if(c==N-1){
                    r++;
                }
                else if(r==0){
                    c++;
                }
                else{
                    r--;c++;
                }
            }
        }
        return res;
    }
};
