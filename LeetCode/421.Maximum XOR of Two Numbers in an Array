421. Maximum XOR of Two Numbers in an Array

/*
Given a non-empty array of numbers, a0, a1, a2, … , an-1, where 0 ≤ ai < 231.
Find the maximum result of ai XOR aj, where 0 ≤ i, j < n.
Could you do this in O(n) runtime?

Example:
Input: [3, 10, 5, 25, 2, 8]
Output: 28
Explanation: The maximum result is 5 ^ 25 = 28.
*/

Solution 1: O(n^2) TLE
class Solution {
public:
    int findMaximumXOR(vector<int>& nums) {
        int len=nums.size();
        int res=0;//i,j可以相等 任意一个数与自己的异或操作等于0
        for(int i=0;i<len;i++){
            for(int j=i+1;j<len;j++)
                res=max(res,nums[i]^nums[j]);
        }
        return res;
    }
};

Solution 2:
class Solution {
    /*
    利用XOR的性质，a^b = c, 则有 a^c = b，且 b^c = a;
    所以每次从高位开始，到某一位为止，所能获得的最大的数。设置变量mask用来表示能形成的值，每一次将mask和其他的num相与得到的值加入set，表示在当前这一位上， 
    数组里有这么多prefix。
    假定在某一位上的任意两数xor能得到的最大值是tmp,那么他一定满足a(xor)b = tmp,其中set.contains(a) && set.contains(b).
    所以只需要判断b(xor)tmp的结果是不是在当前这一位下的set内，就可以知道这个tmp能不能又这个set中的任意两个数组成。
    */
    public int findMaximumXOR(int[] nums) {
        int res=0;//最小值就是0 任意数和自己的XOR都等于0
        int mask=0;
        for(int i=31;i>=0;i--){
            mask=mask|(1<<i);//能形成的最大值
            Set<Integer> set=new HashSet<>();//保存每个数到该位能形成的前缀
            for(int num:nums)
                set.add(num&mask);
            int temp=res|(1<<i);
            for(Integer prefix:set){
                if(set.contains(prefix^temp)){
                    res=temp;
                    break;
                }
            }
        }
        return res;
    }
}

class Solution {
public:
    /*
        方法2:利用a^b = max => max ^a =b的性质
        参考https://kingsfish.github.io/2017/12/15/Leetcode-421-Maximum-XOR-of-Two-Numbers-in-an-Array/
    */
    
    int findMaximumXOR(vector<int>& nums) {
        int curMax=0;
        int mask=0;
        for(int i=31;i>=0;i--){
            // 更新mask来获取前i位数
            mask = mask | (1<<i);
            unordered_set<int> s;
            // 获取前i位数
            for(auto num: nums)
                s.insert(mask&num);
            int temp=curMax | (1<<i);//假设max的该位为1
            for(auto a:s){
                if(s.find(temp^a)!=s.end()){
                    curMax=temp;
                    break;
                }
            }
        }
        return curMax;
    }
};

Solution 3:trie tree
class Solution {
public:
    /*
        方法3:利用Trie Tree或二叉树(只有左右两个孩子 表示0,1)
        https://discuss.leetcode.com/topic/63207/java-o-n-solution-using-trie
        构建Trie树 当从根节点从上到下遍历
        如果某一个节点左右子树都不为空，那么得到最终答案的两个数字肯定分别出自于左右子树且此位为1
        如果任意一个为空，那么最终答案该位为0，依次迭代得到最终结果
    */
    
    int findMaximumXOR(vector<int>& nums) {
        int res=INT_MIN;
        // build tree
        Trie *root=new Trie;
        for(auto num:nums){
            Trie *cur=root;
            for(int i=31;i>=0;i--){
                int curBit=(num>>i)&1;
                if(cur->bits[curBit]==NULL){
                    cur->bits[curBit]=new Trie;
                }
                cur=cur->bits[curBit];
            }
        }
        
        // findMax
        for(auto num:nums){
            Trie *cur=root;
            int temp=0;
            for(int i=31;i>=0;i--){
                int curBit=(num>>i)&1;
                // 是否存在兄弟节点 存在则该位异或就可以获得1
                if(cur->bits[curBit ^ 1]!=NULL){
                    temp+=(1<<i);
                    cur=cur->bits[curBit ^ 1];
                }
                else
                    cur=cur->bits[curBit];
            }
            res=max(res,temp);
        }
        return res;
    }
    
    struct Trie{
        Trie * bits[2]; //分别表示该位为0,1
        Trie(){
            bits[0]=bits[1]=NULL;
        }
    };
};
