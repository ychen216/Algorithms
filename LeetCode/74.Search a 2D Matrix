74. Search a 2D Matrix

/*
Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:

Integers in each row are sorted from left to right.
The first integer of each row is greater than the last integer of the previous row.
For example,

Consider the following matrix:

[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
Given target = 3, return true.
*/

Solution 1:
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int row=matrix.size();
        if(row==0)
            return false;
        int col=matrix[0].size();
        if(col==0)
            return false;
        int targetRow=-1;
        //找到目标行
        for(int i=0;i<row;i++)
            if(matrix[i][col-1]>=target){
                targetRow=i;
                break;
            }
        if(targetRow==-1)//比矩阵最大的数还大
            return false;
        int low=0,high=col-1;
        while(low<=high){
            int mid=low+(high-low)/2;
            if(matrix[targetRow][mid]==target)
                return true;
            else if(matrix[targetRow][mid]<target)
                low=mid+1;
            else
                high=mid-1;
        }
        return false;
    }
};


Solution 2: O(m+n)
class Solution {
public:
    // 从矩阵的右上方开始搜索
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int row=matrix.size();
        if(row==0)
            return false;
        int col=matrix[0].size();
        if(col==0)
            return false;
        int i=0,j=col-1;
        while(i<row&&j>=0){
            if(matrix[i][j]==target)
                return true;
            if(matrix[i][j]>target)
                j--;
            else
                i++;
        }
        return false;
    }
};

Solution 3: log(mn)=log(m)+log(n)
class Solution {
public:
    /*
        将matrix当做一个有一定规律顺序的一维数组 然后用二分搜索
        如果搜索到一个数字num>target 要减小行或者列 即向前搜索
        如果搜索到一个数字num<target 要增加行或者列 即向后搜索
        n * m matrix convert to an array => matrix[x][y] => a[x * m + y]
        an array convert to n * m matrix => a[x] =>matrix[x / m][x % m];
    */
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int row=matrix.size();
        if(row==0)
            return false;
        int col=matrix[0].size();
        if(col==0)
            return false;
        int low=0,high=row*col-1,mid,mid_value;
        while(low<=high){
            mid=low+(high-low)/2;
            mid_value=matrix[mid/col][mid%col];
            if(mid_value==target)
                return true;
            if(mid_value>target)
                high=mid-1;
            else
                low=mid+1;
        }
        return false;
    }
};
